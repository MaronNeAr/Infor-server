### 第一章   绪论

数据：数据库中存储的基本对象

数据库：长期存储在计算机内、有组织的、可共享的大量数据的集合

* 特征：可共享、冗余小、易扩展

数据库管理系统：用户与操作系统间数据管理软件

* 功能：数据定义、数据组织、存储和管理、数据操作、事务管理、数据库建立和维护

数据库系统:

* 构成：数据库、数据库管理系统、应用程序、DBA 

##### 数据模型

概念模型：实体、属性、码、实体型、实体集、联系

组成要素：

* 数据结构：描述数据库的组成对象，以及对象之间的联系

* 数据操作：对数据库中各种对象（型）的实例（值）允许执行的 操作的集合，包括操作及有关的操作规则

* 数据完整性约束：给定的数据模型中数据及其联系所具有 的制约和依存规则

常用的数据模型：

* 层次模型、网状模型、关系模型

* 面向对象数据模型、对象关系数据模型、半结构化数据模型：

层次模型：

![image-20221105161549453](C:\Users\hua'wei\AppData\Roaming\Typora\typora-user-images\image-20221105161549453.png)

网状模型：

![image-20221105161830820](C:\Users\hua'wei\AppData\Roaming\Typora\typora-user-images\image-20221105161830820.png)

关系模型：关系表、元组、属性、主码、域（同种数据类型）、分量、关系模式

![image-20221105161902856](C:\Users\hua'wei\AppData\Roaming\Typora\typora-user-images\image-20221105161902856.png)

##### 数据库系统结构

模式：数据库逻辑结构和特征的描述

实例：模式的一个具体值

三级模式结构：

* 模式：数据库中全体数据的逻辑结构和特征描述，即数据表

* 外模式：数据库用户的局部数据描述，用户能够访问的部分，即用户视图

* 内模式：数据物理结构和存储方式的描述

![image-20221105162801220](C:\Users\hua'wei\AppData\Roaming\Typora\typora-user-images\image-20221105162801220.png)

二级映像和数据独立性：

* 模式/外模式映像：全局逻辑结构和局部逻辑结构的对应关系

* 模式/内模式映像：全局逻辑结构与存储结构的对应关系

### 第二章 关系数据库

##### 关系模型概述

关系

* 域：一组具有相同数据类型的值的集合，即一列数据

* 笛卡尔积：符合条件的元组集合，即查询结果二维表
* 元组：笛卡尔积的每一个元素，即一个条目
* 分量：每一个di叫做分量，即一个属性值
* 基数：笛卡尔积的元组个数
* 关系：D1 * D2 * D3 * D4 的子集
* 属性：字段名称
* 码
  - 候选码：能唯一表示一个元组
  - 全码：所有属性组是这个关系的候选码
  - 主码：其中一个候选码
  - 主属性：候选码的主属性

三类关系：基本关系（基本表）、查询表、视图表（虚表）

关系模式：*R（U, D, DOM, F）*简化表示：*R（U, F）*

![image-20221105173339593](C:\Users\hua'wei\AppData\Roaming\Typora\typora-user-images\image-20221105173339593.png)

关系数据库：在一个给定的应用领域中，所有关系的集合构成一 个关系数据库

##### 关系操作

查询操作：选择、投影、连接、除、并、差、交、笛卡尔积

数据更新：插入、删除、修改

##### 关系的完整性

实体完整性：主码属性不能取空值

参照完整性：外码F是空值或者等于基本关系S中某个元组的主码值

自定义完整性：

- 属性的约束条件：不取空值、列值唯一、满足条件表达式

- 元组的约束条件：多个属性值之间的约束条件

##### 关系代数

![image-20221106115534013](C:\Users\hua'wei\AppData\Roaming\Typora\typora-user-images\image-20221106115534013.png)

连接：

<span>![image-20221106123701028](C:\Users\hua'wei\AppData\Roaming\Typora\typora-user-images\image-20221106123701028.png)</span><span>![image-20221106123720092](C:\Users\hua'wei\AppData\Roaming\Typora\typora-user-images\image-20221106123720092.png)</span>

- 等值连接：R和S中属性A和属性B相同

![image-20221106123955371](C:\Users\hua'wei\AppData\Roaming\Typora\typora-user-images\image-20221106123955371.png)

- 自然连接：R和S必有相同的属性组

![image-20221106124128437](C:\Users\hua'wei\AppData\Roaming\Typora\typora-user-images\image-20221106124128437.png)

- 左外连接：只保留R 的悬浮元组

- 右外连接：只保留S的悬浮元组

### 第三章 关系数据库语言SQL

##### SQL概述

* DDL：数据定义语句CREATE、DROP、ALTER

* DML：数据操纵INSERT、UPDATE、DELETE

* DCL：数据控制GRANT、REVOKE

* DQL：数据库查询SELECT

##### 数据定义

![image-20221106133701120](C:\Users\hua'wei\AppData\Roaming\Typora\typora-user-images\image-20221106133701120.png)

*CREATE SCHEMA “S-T” AUTHORIZATION WANG;*

*DROP SCHEMA <模式名><CASCADE|RESTRICT>*

- CASCADE（级联）：删除模式的同时把该模式中所有的数据库对象全部删除

- RESTRICT（限制）：如果该模式中定义了下属的数据库对象（如表、视图 等），则拒绝该删除语句的执行。

CREATE TABLE：

- >*CREATE TABL E <表名>*
  >
  >*(<列名> <数据类型>[ <列级完整性约束条件> ]*
  >
  >*[,<列名> <数据类型>[ <列级完整性约束条件>] ]*
  >
  >… 
  >
  >*[,<表级完整性约束条件> ] );*

ALTER TABLE：

- > *ALTER TABLE <表名>*
  >
  > *[ ADD[COLUMN] <新列名> <数据类型> [ 完整性约束 ] ]*
  >
  > *[ ADD <表级完整性约束>]*
  >
  > *[ DROP [ COLUMN ] <列名> [CASCADE | RESTRICT]]*
  >
  > *[DROP CONSTRAINT<完整性约束名>[ RESTRICT | CASCADE]*
  >
  > *[[ALTER COLUMN <列名><数据类型> ];*

*CREATE VIEW view  AS<查询语句>*

*CREATE [UNIQUE] [CLUSTER] INDEX <索引名> ON <表名>(<列名>[<次序>][,<列名>[<次序>] ]…);*

- > UNIQUE：此索引的每一个索引值只对应唯一的数据记录
  >
  > CLUSTER：表示要建立的索引是聚簇索引

*ALTER INDEX <旧索引名> RENAME TO <新索 引名>*

##### 数据查询

- >*SELECT [ALL|DISTINCT] <目标列表达式>[,<目标列表达式>] …*
  >
  >*FROM <表名或视图名>[,<表名或视图名> ]…|(SELECT 语句)[AS]<别名>*
  >
  >*[ WHERE <条件表达式> ]*
  >
  >*[ GROUP BY <列名1>[ HAVING <条件表达式> ] ]*
  >
  >*[[ ORDER BY <列名2> [ ASC|DESC ]];*

* SELECT子句：指定要显示的属性列 
* FROM子句：指定查询对象（基本表或视图）
*  WHERE子句：指定查询条件 
* GROUP BY子句：对查询结果按指定列的值分组，该 属性列值相等的元组为一个组。通常会在每组中作用聚 集函数。 
* HAVING短语：只有满足指定条件的组才予以输出 
* ORDER BY子句：对查询结果表按指定列值的升序或降序排序

![image-20221106144942650](C:\Users\hua'wei\AppData\Roaming\Typora\typora-user-images\image-20221106144942650.png)

- LOWER：全部小写
- UPPER：全部大写
- DISTINCT：消除重复行

*LIKE 'DB\_Design' ESCAPE '\ ' ;*

聚集函数

- 统计元组个数：COUNT(*) 
- 统计一列中值的个数：COUNT([DISTINCT|ALL] <列名>) 
- 计算一列值的总和（此列必须为数值型）：SUM([DISTINCT|ALL] <列名>) 
- 计算一列值的平均值（此列必须为数值型）： AVG([DISTINCT|ALL] <列名>) 
- 求一列中的最大值和最小值 MAX([DISTINCT|ALL] <列名>)： MIN([DISTINCT|ALL] <列名>)

ANY或ALL语句：*WHERE col < ANY (SELECT语句)*

- \>ANY 大于子查询结果中的某个值
- \>ALL 大于子查询结果中的所有值< ANY 小于子查询结果中的某个值
- < ALL 小于子查询结果中的所有值
- \>= ANY 大于等于子查询结果中的某个值
- \>= ALL 大于等于子查询结果中的所有值
- <= ANY 小于等于子查询结果中的某个值 
- <= ALL 小于等于子查询结果中的所有值
- = ANY 等于子查询结果中的某个值 
- =ALL 等于子查询结果中的所有值（通常没有实际意义）
- !=（或<>）ANY 不等于子查询结果中的某个值 
- !=（或<>）ALL 不等于子查询结果中的任何一个值

![image-20221106164248424](C:\Users\hua'wei\AppData\Roaming\Typora\typora-user-images\image-20221106164248424.png)

EXISTS：返回值为真或假

集合查询：

- UNION：将多个查询结果合并起来时，系统自动去掉重复元组 
- UNION ALL：将多个查询结果合并起来时，保留重复元组
- INTERSECT：并集
- EXCEPT：差操作

##### 数据更新

插入元组

- INSERT INTO <表名> [(<属性列1>[,<属性列2 >…)]
- VALUES (<常量1> [,<常量2>]… );

修改数据

- UPDATE <表名> 
- SET <列名>=<表达式>[,<列名>=<表达式>]… 
- [WHERE <条件>];
- \*会检查是否破坏完整性

删除数据

- DELETE FROM <表名> 
- [WHERE <条件>];

##### 空值的处理

![image-20221106170817930](C:\Users\hua'wei\AppData\Roaming\Typora\typora-user-images\image-20221106170817930.png)

### 第四章 数据库安全性

安全措施：

- 用户身份鉴别、存取控制和视图等技术。
- 强制存取控制、数据加密存储、加密传输、审计日志分析

安全级别：

![image-20221106173748427](C:\Users\hua'wei\AppData\Roaming\Typora\typora-user-images\image-20221106173748427.png)

##### 数据库安全性控制

数据库安全性控制常用方法：用户身份鉴定、存取控制、视图、审计、数据加密

- 自主存取控制（DAC）：C2级，不同用户，不同数据都有不同的存取权限，通过GRANT和REVIKE实现
- 强制存取控制（MAC）：B1级，数据有密级，用户被授予许可证

![image-20221106174853849](C:\Users\hua'wei\AppData\Roaming\Typora\typora-user-images\image-20221106174853849.png)

GRANT语句

- GRANT <权限>[,<权限>]... 

- ON <对象类型> <对象名>[,<对象类型> <对象名>]… 

- TO <用户>[,<用户>]... 

- [WITH GRANT OPTION];

REVOKE语句

- REVOKE <权限>[,<权限>]... 

- ON <对象类型> <对象名>[,<对象类型><对象名>]… 

- FROM <用户>[,<用户>]...[CASCADE | RESTRICT];

创建数据库模式的权限

- CREATE USER   

- [WITH] [DBA|RESOURCE|CONNECT];

![image-20221106180414742](C:\Users\hua'wei\AppData\Roaming\Typora\typora-user-images\image-20221106180414742.png)

*RESOURCE可以CREATE TABLE 可以执行数据查询和操纵

数据库角色：*CREATE ROLE <角色名>*

审计：*AUDIT ALTER,UPDATE  ON SC;*

##### 数据加密—— 防止数据库中数据在存储和传输中失密的有效手段

基本思想

- 根据一定的算法将原始数据—明文（Plain text）

- 变换为不可直接识别的格式—密文（Cipher text）

加密方法

* 存储加密
  - 透明存储加密：对用户完全透明，性能好
  - 非透明存储加密：通过多个加密函数实现

* 传输加密

  - 链路加密：链路层进行加密

  - 端到端加密在发送端加密，接收端解密

### 第五章 数据库完整性

##### 实体完整性

定义列级约束条件：PRIMARY KEY

定义表级约束条件：PRIMARY(主码)

##### 参照完整性

定义列级约束条件：FOREIGN KEY  REFERENCES Student(主码)

定义表级约束条件：FOREIGN KEY (主码) REFERENCES Student(主码)

![image-20221106203552924](C:\Users\hua'wei\AppData\Roaming\Typora\typora-user-images\image-20221106203552924.png)

参照完整性违约处理

* 拒绝执行（NO ACTION）
* 级联操作（CASCADE）操作
* 设置为空值（SET-NULL）

##### 用户定义的完整性

定义属性上的约束条件

* 列值非空（NOT NULL）
* 列值唯一（UNIQUE）
*  检查列值是否满足一个条件表达式（CHECK）： CHECK （性别 IN （‘男’,’女’））

完整性约束命名字句

* CONSTRAINT <完整性约束条件名><完整性约束条件>

##### 断言：即约束条件

CREATE ASSERTION<断言名><CHECK 子句>

DROP ASSERTION <断言名>

##### 触发器

CREATE / DROP TRIGGER

* > CREATE TRIGGER <触发器名>  
  >
  > {BEFORE | AFTER} <触发事件> ON <表名> 
  >
  > REFERENCING NEW|OLD ROW AS<变量> 
  >
  > FOR EACH {ROW | STATEMENT}
  >
  > [WHEN <触发条件>]<触发动作体>

* DROP TRIGGER <触发器名> ON <表名>;

### 第六章 关系数据理论

##### 关系数据库的规范化理论

* 数据依赖（数据之间的联系） 
* 范式（关系模式的标准） 
* 模式设计（自动化设计的基础）

##### 数据依赖

函数依赖（Functional Dependency，简记为FD）

* Sno→Sname，Sno→Sdept

* >平凡函数依赖：X包含Y
	>
	>非平凡函数依赖：X不包含Y

* >完全函数依赖：Y不依赖于X的任何真子集，X → Y(F)
	>
	>部分函数依赖：Y依赖于X的其中一真子集，X → Y(P)

* 传递函数依赖：X→Y(Y⊈X)，Y↛X， Y→Z，Z⊈Y

多值依赖（Multi-Valued Dependency，简记为MVD）

关系模式存在的问题

* > 数据冗余： 浪费大量的存储空间
	>
	> 更新异常：数据冗余 ，更新数据时，维护数据完整性代价大。
	>
	> 插入异常
	>
	> 删除异常

* 解决方法：模式分解

##### 范式

第一范式（1NF）

* > 每个字段都是不可分割的原子类型
	>
	> 每个表中的每个字段都是不可再分割的基本值，即不包含任何子字段
	>
	> 每个表只有一个主键
	>
	> 每个表中的所有字段都必须与主键有直接关系，即所有字段都必须依赖主键

第二范式（2NF）

* 如果一个关系满足第一范式（1NF），并且每个非主属性（非主键属性）完全依赖于主键，则称这个关系是第二范式（2NF）。

第三范式（3NF）

* 设关系模式R∈1NF,若R中不存在这样的码X、属性组Y及非主属性Z（Z ⊇ Y）, 使 得X→Y，Y→Z成立，Y ↛ X不成立。
* 即满足第二范式，且没有传递依赖。

修正第三范式（BCNF）

* 消除主属性对候选码的传递依赖

第四范式（4NF）

* 满足第三范式，没有多值依赖

![image-20230101154152429](C:\Users\hua'wei\AppData\Roaming\Typora\typora-user-images\image-20230101154152429.png)



函数闭包

* 对于一个关系 R，如果满足 R 中的所有函数依赖都是完全函数依赖的形式，则称 R 是函数闭包。

最小依赖集

* 最小依赖集是指在一个函数依赖集中，如果有多个函数依赖可以推出另一个函数依赖，那么这些函数依赖就不是最小依赖集的一部分。

### 第七章 数据库设计

##### 数据字典

数据项：数据的最小组成单位

* > 数据项描述 = {
	>
	> ​	数据项名,数据项含义说明,别名, 数据类型,长度,取值范围,取值含义, 与其他数据项的逻辑关系, 数据项之	间的联系
	>
	> }

![image-20230101163858218](C:\Users\hua'wei\AppData\Roaming\Typora\typora-user-images\image-20230101163858218.png)

数据结构：若干个数据项可以组成一个数据结构

* > 数据结构描述 = {
	>
	> ​	数据结构名，
	>
	> ​	含义说明，
	>
	> ​	组成:{数据项或数据结构}
	>
	> }

![image-20230101164019752](C:\Users\hua'wei\AppData\Roaming\Typora\typora-user-images\image-20230101164019752.png)

数据流：数据结构在系统内传输的路径。

* > 数据流描述 = {
	>
	> ​	数据流名,说明,数据流来源, 数据流去向,
	>
	> ​	组成:{数据结构}, 
	>
	> ​	平均流量,高峰期流量
	>
	> }

![image-20230101164810904](C:\Users\hua'wei\AppData\Roaming\Typora\typora-user-images\image-20230101164810904.png)

数据存储:是数据结构停留或保存的地方，也是数据 流的来源和去向之一。

* > 数据存储描述={
	>
	> ​	数据存储名,说明,编号,输 入的数据流 ,输出的数据流, 
	>
	> ​	组成:{数据结构},
	>
	> ​	数据量, 存取频度,存取方式
	>
	> }

![image-20230101164923490](C:\Users\hua'wei\AppData\Roaming\Typora\typora-user-images\image-20230101164923490.png)

处理过程：用判定表或判定树来描 述。数据字典中只需要描述处理过程的说明性信息

* > 处理过程描述 = {
	>
	> ​	处理过程名,说明,
	>
	> ​	输入:{数据流}, 
	>
	> ​	输出:{数据流},
	>
	> ​	处理:{简要说明}
	>
	> }

![image-20230101165041908](C:\Users\hua'wei\AppData\Roaming\Typora\typora-user-images\image-20230101165041908.png)

##### 概念结构设计——ER模型

实体之间的联系

* > ①一对一联系（1∶1）
	>
	> ②一对多联系（1∶n） 
	>
	> ③多对多联系（m∶n）

** 矩形表示实体型、椭圆表示属性、联系表示联系

* 实体及其属性图

![image-20230101184012167](C:\Users\hua'wei\AppData\Roaming\Typora\typora-user-images\image-20230101184012167.png)

* 实体及其联系图

![image-20230101184058306](C:\Users\hua'wei\AppData\Roaming\Typora\typora-user-images\image-20230101184058306.png)

* 完整的实体-联系图

![image-20230101184147065](C:\Users\hua'wei\AppData\Roaming\Typora\typora-user-images\image-20230101184147065.png)

### 第八章 数据库编程

##### 嵌入式SQL

嵌入式SQL的处理过程

* C语言：EXEC SQL  <SQL语句>;

SQL语句

* > 描述性的面向集合的语句
	>
	> 负责操纵数据库

高级语言语句

* > 过程性的面向记录的语句
	>
	> 负责控制逻辑流程

SQL语句与主语言通信

* > 向主语言传递SQL语句的执行状态信息，使主语言能够据此控制程序流程，主要用SQL通信区实现
	>
	> 主语言向SQL语句提供参数，主要用主变量实现
	>
	> 将SQL语句查询数据库的结果交主语言处理，主要用主变量和游标实现

SQLCA（SQL通信）

* > SQL语句执行后，系统反馈给应用程序信息
	>
	> 这些信息将送到SQL通信区中
	>
	> 应用程序从SQL通信区中取出这些状态信息，据此决定接下来执行的语句

##### 游标

* 游标是系统为用户开设的一个数据缓冲区，存放SQL语句的执行结果

* 用户可以用SQL语句逐一从游标中获取记录，并赋给主变量，交由主语言进一步处理

作用：

* > 提取数据：游标可以用来提取数据库表中的数据，方便对数据进行处理。
	>
	> 遍历数据：游标可以用来遍历数据库表中的数据，方便对数据进行操作。
	>
	> 分批处理数据：游标可以用来分批处理大量数据，避免一次性加载过多数据造成的内存问题。
	>
	> 对数据进行特定操作：游标可以用来对数据库表中的数据进行特定的操作，比如更新、删除等

不用游标的SQL语句：

* > 说明性语句
	>
	> 数据定义语句
	>
	> 数据控制语句
	>
	> 查询结果为单记录的SELECT语句
	>
	> 非CURRENT形式的增删改语句

使用游标的SQL语句：

* > 查询结果为多条记录的SELECT语句
	>
	> CURRENT形式的UPDATE语句
	>
	> CURRENT形式的DELETE语句

使用游标的步骤：

* > 说明游标：EXEC SQL DECLARE <游标名> CURSOR FOR <SELECT语句>;
	>
	> 打开游标：EXEC SQL OPEN <游标名>;
	>
	> 推进游标指针并取当前记录：EXEC SQL FETCH <游标名>  
	>
	> ​												  INTO <主变量>[<指示变量>] [,<主变量>[<指示变量>]]...;
	>
	> 关闭游标：EXEC SQL CLOSE <游标名>;

##### 过程化SQL

过程化SQL结构

* > 定义部分：DECLARE 变量、常量、游标、异常等
	>
	> 执行部分： BEGIN 
	>
	> ​						SQL语句、过程化SQL的流程控制语句 
	>
	> ​					EXCEPTION 异常处理部分 
	>
	> ​					END；

变量和常量定义：

* > 变量定义：
	>
	> - 变量名 数据类型 [[NOT NULL]:=初值表达式]
	> -  变量名 数据类型 [[NOT NULL] 初值表达式]
	>
	> 常量定义：
	>
	> - 常量名 数据类型 CONSTANT :=常量表达式
	> - 常量必须要给一个值，并且该值在存在期间或常量的作用域内不能改变。如果试图修改它，过程化SQL将返回一个异常
	>
	> 赋值语句： 变量名称 :=表达式

流程控制

* > 条件控制语句：IF-THEN、IF-THEN-ELSE
	>
	> 循环控制语句：LOOP、WHILE-LOOP、FOR-LOOP
	>
	> 错误处理：TRY-CATCH

##### 存储过程和函数

存储过程

* > 命名块：编译后保存在数据库中，可以被反复调用，运行速度较 快，过程和函数是命名块
	>
	> 匿名块：每次执行时都要进行编译，它不能被存储到数据库中， 也不能在其他过程化SQL块中调用

* 优点

	> 运行效率高
	>
	> 降低了客户机和服务器之间的通信量
	>
	> 方便实施企业规则

* 用户接口

	> 创建存储过程：CREATE OR REPLACE PROCEDURE 过程名([参数1, 参数2,...]) AS <过程化SQL块>；
	>
	> 执行存储过程：CALL/PERFORM PROCEDURE 过程名([参数1,参数2,...])；
	>
	> 修改存储过程：ALTER PROCEDURE 过程名1 RENAME TO 过程名2;
	>
	> 删除存储过程：DROP PROCEDURE 过程名()；

函数

* > 同：都是持久性存储模块
	>
	> 异：函数必须指定返回的类型

* > 定义：CREATE OR REPLACE FUNCTION 函数名 ([参数1,参 数2,…]) 
	>
	> ​            RETURNS <类型> 
	>
	> ​            AS <过程化SQL块>;
	>
	> 执行：CALL/SELECT 函数名 ([参数1,参数2,…]);
	>
	> 修改：ALTER FUNCTION 过程名1 RENAME TO 过程名2;
	>
	> 删除：ALTER FUNCTION 过程名 COMPILE;

##### ODBC编程

体系结构

* 用户应用程序

	* > 请求连接数据库
		>
		> 向数据源发送SQL语句
		>
		> 为SQL语句执行结果分配存储空间，定义所读取的数据格式
		>
		> 获取数据库操作结果或处理错误
		>
		> 进行数据处理并向用户提交处理结果
		>
		> 请求事务的提交和回滚操作
		>
		> 断开与数据源的连接

* ODBC驱动程序管理器

	* >装载ODBC驱动程序
		>
		>选择和连接正确的驱动程序
		>
		>管理数据源
		>
		>检查ODBC调用参数的合法性
		>
		>记录ODBC函数的调用等

* 数据库驱动程序

	* > 提供应用系统与数据库平 台的独立性

* 数据源

	* > 是最终用户需要访问的数据，包含了数 据库位置和数据库类型等信息，是一种数据连接 的抽象

![image-20230101215008639](C:\Users\hua'wei\AppData\Roaming\Typora\typora-user-images\image-20230101215008639.png)

### 第十章 数据库恢复技术

##### 事物

* >事务(Transaction)是用户定义的一个数据库操作序列， 这些操作要么全做，要么全不做，是一个不可分割的工 作单位
	>
	>事务是恢复和并发控制的基本单位

事物的ACID特性

* > 原子性（Atomicity）：事务是数据库的逻辑工作单位, 事务中包括的诸操作要么都做，要么都不做
	>
	> 一致性（Consistency）： 事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态
	>
	> 隔离性（Isolation）：一个事务的执行不能被其他事务干扰
	>
	> 持续性（Durability）：一个事务一旦提交，它对数据库中数据的改变就应该 是永久性的。

COMMIT 和 ROLLBACK

##### 故障の种类

* > 事物内部故障
	>
	> 系统故障
	>
	> 介质故障
	>
	> 计算机病毒

恢复的实现技术

* > 数据转储：静态转储与动态转储、海量转储与增量转储
	>
	> 登记日志文件：用来记录事务对数据库的更新操作 的文件

##### 恢复策略

事物故障的恢复

* 原因：事务在运行至正常终止点前被终止

* >  由恢复子系统利用日志文件撤消（UNDO）此事务已对数据库进行的修改

* 事务故障的恢复由系统自动完成，对用户是透明的，不需要用户干预

系统故障的恢复

* 原因：

	> 未完成事务对数据库的更新可能已写入数据库
	>
	> 已提交事务对数据库的更新可能还留在缓冲区没来得及写入数据库

* > Undo 故障发生时未完成的事务
	>
	> Redo 已完成的事务

*  系统故障的恢复由系统在重新启动时自动完成，不需要用户干预

介质故障的恢复

* > 重装数据库
	>
	> Redo 已完成的事务

检查点恢复技术

* > 在日志文件中增加检查点记录（checkpoint）
	>
	> 增加重新开始文件
	>
	> 恢复子系统在登录日志文件期间动态地维护日志

数据库镜像

* > 据库管理系统自动把整个数据库或其中的关键数据复制到另一个磁盘上
	>
	> 数据库管理系统自动保证镜像数据与主数据的一致性每当主数据库更新时，数据库管理系统自动把更新后 的数据复制过去

### 第十一章 并发控制

##### 多事物执行方式

* > 事物串行执行：单处理机串行
	>
	> 交叉并发执行：单处理机并发
	>
	> 同时并发执行：多处理机

* 并发控制机制的任务

	> 对并发操作进行正确调度
	>
	> 保证事务的隔离性
	>
	> 保证数据库的一致性

* 并发操作带来的数据不一致性

	> 丢失修改（Lost Update）
	>
	> 不可重复读（Non-repeatable Read）：不可重复读是指事务T1读取数据后，事务T2 执行更新操作，使T1无法再现前一次读取结果
	>
	> 读“脏”数据（Dirty Read）：

##### 封锁

排它锁（Exclusive Locks，简记为X锁）：写锁

* 若事务T对数据对象A加上X锁，则只允许T读取 和修改A，其它任何事务都不能再对A加任何类型 的锁，直到T释放A上的锁

共享锁（Share Locks，简记为S锁）：读锁

* 若事务T对数据对象A加上S锁，则事务T可以读A 但不能修改A，其它事务只能再对A加S锁，而不 能加X锁，直到T释放A上的S锁

![image-20230102154510252](C:\Users\hua'wei\AppData\Roaming\Typora\typora-user-images\image-20230102154510252.png)

封锁协议

* > 一级封锁协议：事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放。
	>
	> - 一级封锁协议可防止丢失修改，并保证事务T是可恢复的。
	>
	> 二级封锁协议：一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，读完后即可释放S锁。
	>
	> - 二级封锁协议可以防止丢失修改和读“脏”数据。
	>
	> 三级封锁协议：一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，直到事务结束才释放。
	>
	> - 三级封锁协议可防止丢失修改、读脏数据和不可重复读。

##### 活锁和死锁

死锁的预防

* > 一次封锁法：要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行
	>
	> 顺序封锁法：顺序封锁法是预先对数据对象规定一个封锁顺序，所有事 务都按这个顺序实行封锁。

死锁的诊断

* > 超时法：如果一个事务的等待时间超过了规定的时限，就认为 发生了死锁
	>
	> 等待图法：用事务等待图动态反映所有事务的等待情况

两段锁协议

* 指所有事务必须分两个阶段对数据项加锁和解锁

* > 1) 在对任何数据进行读、写操作之前，事务首先要获得对该数据的封锁
	>
	> 2) 在释放一个封锁之后，事务不再申请和获得任何其他封锁

### 附录

* > 数据库三级模式；两级映射
	> 关系代数集合运算（并、差、交、笛卡尔积）
	> 关系代数专门关系运算（选择、投影、连接、除）
	> SQL--数据定义（模式、表、视图、索引的创建与删除、修改）
	> SQL--单表查询(查询指定列，指定元组，order by； 聚集函数；group by）
	> SQL--连接查询（1.等值与非等值连接查询 ；2.自身连接；3.外连接；4.多表连接）
	> SQL--嵌套查询（带有IN谓词的子查询 ； 带有比较运算符的子查询；）
	> SQL--集合查询（并操作UNION；交操作INTERSECT；差操作EXCEPT）
	> SQL--视图（定义视图；查询视图；删除视图）
	> 数据库安全性控制的常用方法（用户标识与鉴定；存取控制；视图；审计；数据加密）
	> 数据库安全的两个常用标准（TESEC,CC标准）
	> DBMS常用存取控制方法（DAC）（MAC)
	> SQL 的GRANT 语句和REVOKE 语句; ROLE的CREATE 和GRANT,REVOKE
	> 数据库完整性（在表上定义实体完整性，参照完整性，PRIMARY KEY ； FOREIGN KEY 。。REFERENCES 。。）  用户定义完整性（列值非空（NOT NULL）；列值唯一（UNIQUE）；检查列值是否满足一个条件表达式（CHECK））
	> 定义触发器（   CREATE TRIGGER <触发器名>    {BEFORE | AFTER} <触发事件> ON <表名>     REFERENCING NEW|OLD ROW AS<变量>       FOR EACH  {ROW | STATEMENT}       [WHEN <触发条件>]<触发动作体>）
	> 关系规范化：一二三范式；完全函数依赖，部分函数依赖，多值依赖；函数闭包；最小依赖集
	> 数据字典表示方法
	> E-R图表示方法（两种表示形式都可以）；学会熟练根据需求绘制E-R图
	> 嵌入式SQL处理过程；游标作用；使用游标的SQL语句
	> 过程化SQL存储过程
	> ODBC体系结构和工作原理
	> 并发的三类问题；三级封锁协议；活锁与死锁；两段锁协议
	> 事务ACID特性；数据库主要故障种类，恢复主要策略（存储、日志文件、检查点、镜像）；

